\documentclass[11pt, a4paper, oneside]{book}

% URLs and hyperlinks ---------------------------------------
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=blue,
}
\usepackage[inline]{enumitem}
\usepackage{xurl}

\usepackage{caption}
%---------------------------------------------------

% page headers -------------------------------------------------
\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}}
\pagestyle{fancy}
\fancyhf{}% Clear header/footer
\fancyhead[L]{\nouppercase\leftmark}
\fancyhead[R]{\thepage}
%---------------------------------------------------------------

% adjust a verrrrry big table -------------------------------
\usepackage{adjustbox}
% -----------------------------------------------------------

% titlepage -------------------------------------------------
\usepackage{pdfpages}
%------------------------------------------------------------


% Rn custom item in enumeration -----------------------------
\newcounter{itemadded}
\setcounter{itemadded}{0}


\newcommand{\addeditem}{%
	\addtocounter{enumi}{-1}%
	\stepcounter{itemadded}
	\let\LaTeXStandardLabelEnumi\labelenumi%
	\addtocounter{enumi}{1}
	\renewcommand{\labelenumi}{\arabic{enumi}\lr{R}.}%
	\item 
	% Switch back to old labelling 
	\let\labelenumi\LaTeXStandardLabelEnumi%
}%


\let\LaTeXStandardEnumerateBegin\enumerate
\let\LaTeXStandardEnumerateEnd\endenumerate

\renewenvironment{enumerate}{%
	\LaTeXStandardEnumerateBegin%
	\setcounter{itemadded}{0}
}{%
	\LaTeXStandardEnumerateEnd%
}%
% -----------------------------------------------------------

% tables -------------------------------------------------------
\usepackage{float}
\usepackage{multirow}
\renewcommand{\arraystretch}{1.23}
% ---------------------------------------------------------------------

\usepackage{listings}
\usepackage{forest}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=R,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage{xepersian}
\settextfont{Yas}
\setdigitfont{Yas}
\setlatintextfont{Yas}

\renewcommand{\lstlistlistingname}{فهرست کد‌ها}
\renewcommand{\bibname}{منابع}


\begin{document}
	\begin{titlepage}
		\centering
		\includegraphics[width=3.2cm, height=3.2cm]{images/logo}\par
		\vspace{5mm}
		{\LARGE دانشگاه اصفهان}\par
		\vspace{5mm}
		{\Large دانشکده مهندسی کامپیوتر}\par
		
		\vspace{2cm}
		
		{\Large گزارش پروژه}\par
		
		\vspace{1cm}
		
		{\Large درس زبان‌های برنامه نویسی}\par
		
		\vspace{1cm}
		{\Huge بررسی زبان \lr{R}}\par
		
		
		\vspace{2cm}
		{\Large سیدمحمدحسین هاشمی}\par
		{\Large بردیا جوادی}\par
		\vspace{1cm}
		{\large استاد : دکتر آرش شفیعی}\par

		\vspace{2cm}
		
		% Bottom of the page
		{\large پاییز 1403\par}
	\end{titlepage}
	
	\clearpage
	\begin{center}
		\includegraphics[width=10cm]{images/image002}
	\end{center}  
	\thispagestyle{plain}\mbox{} 
	\clearpage
	
	\tableofcontents
	\listoftables 
	%\listoffigures
	\lstlistoflistings
	\newpage
	
	\chapter{مقدمه}
	
		\section{تاریخچه زبان \lr{R}}
			
			زبان برنامه‌نویسی \lr{R} در ابتدا با هدف ساده‌سازی تحلیل‌های آماری و مدل‌سازی داده‌ها طراحی شد. این زبان که توسط راس ایهاکا و رابرت جنتلمن در دهه 1990 ابداع شد، به عنوان یک ابزار متن‌باز برای تحلیل داده‌های پیچیده توسعه یافت. در آن زمان، نیاز به زبانی که توانایی تحلیل آماری پیشرفته، مدل‌سازی ریاضی و تولید گراف‌های بصری را داشته باشد، به شدت احساس می‌شد. زبان \lr{R} با الهام از زبان \lr{SAS} طراحی شد و توانست مشکلاتی نظیر عدم انعطاف‌پذیری ابزارهای آماری موجود و محدودیت‌های گرافیکی آنها را برطرف کند. همچنین، متن‌باز بودن \lr{R} موجب شد که جامعه‌ای پویا از کاربران و توسعه‌دهندگان حول آن شکل بگیرد، که این امر به گسترش سریع امکانات و کتابخانه‌های آن کمک کرد.
		
		
		\section{ویژگی‌های زبان \lr{R}}
		
			\lr{R} به دلیل قابلیت‌های منحصربه‌فرد خود در حوزه‌های مختلف کاربرد گسترده‌ای دارد. از جمله مهم‌ترین حوزه‌ها می‌توان به موارد زیر اشاره کرد:
			
			\begin{itemize}
				
				\item {\large تحلیل داده‌ها و آمار پیشرفته}: 
				{\normalsize به‌طور خاص برای تحلیل‌های آماری پیچیده و مدل‌سازی داده‌ها طراحی شده است.}
				
				\item {\large یادگیری ماشین و هوش مصنوعی}:
				{\normalsize بسیاری از الگوریتم‌های یادگیری ماشین و ابزارهای هوش مصنوعی در پیاده‌سازی شده‌اند.}
				
				\item {\large مصورسازی داده‌ها}:
				{\normalsize قابلیت‌های گرافیکی پیشرفته آن را به ابزاری مناسب برای ایجاد نمودارهای حرفه‌ای و گزارش‌های بصری تبدیل کرده است.}
				
				\item {\large بیوانفورماتیک}:
				{\normalsize در تحلیل داده‌های زیستی، از جمله داده‌های ژنومی و پروتئومی، کاربرد فراوان دارد.}
				
				\item {\large امور مالی و اقتصادی}:
				{\normalsize بسیاری از مدل‌های مالی و پیش‌بینی‌های اقتصادی با استفاده از \lr{R} پیاده‌سازی می‌شوند.}
				
				\item {\large تحقیقات علمی}:
				{\normalsize به‌عنوان یک ابزار تحقیقاتی در علوم اجتماعی، روانشناسی و بسیاری از رشته‌های علمی مورد استفاده قرار می‌گیرد.
					علاوه بر این، \lr{R} به دلیل پشتیبانی گسترده از کتابخانه‌های تخصصی، امکان تحلیل‌های پیشرفته در حوزه‌های خاص را فراهم می‌کند.}
					
				\item {\large بازاریابی و تحلیل مشتری}:
				{\normalsize کسب‌وکارها از برای تحلیل رفتار مشتری، تقسیم‌بندی بازار و پیش‌بینی فروش استفاده می‌کنند.
				}
				
			\end{itemize}
			
			
		\section{هدف از ایجاد زبان و مشکلاتی که رفع کرد}
		
		 	\lr{R} برای حل مشکلات خاصی طراحی شد که در آن زمان در زبان‌های موجود دیده می‌شد:
			
			\begin{itemize}
				
				\item {\large رایگان و منبع‌باز بودن}:
				{\normalsize در دهه 90، بسیاری از ابزارهای آماری مثل \lr{SAS} و \lr{MATLAB} هزینه‌های بالایی داشتند. \lr{R} به عنوان یک جایگزین رایگان و منبع‌باز برای این ابزارها توسعه یافت.}
				
				\item {\large سازگاری با زبان \lr{SAS}}:
				{\normalsize کاربران زبان \lr{SAS} می‌توانستند کدهای خود را با تغییرات جزئی در \lr{R} اجرا کنند. این ویژگی، پذیرش \lr{R} را تسریع کرد.}
				
				\item {\large انعطاف‌پذیری بالا}:
				{\normalsize \lr{R} به طور خاص برای تحلیل آماری و مصورسازی داده‌ها بهینه‌سازی شده بود و نیازهای تحلیل‌گران را بهتر از زبان‌های عمومی مثل \lr{C} یا \lr{Java} برآورده می‌کرد.
				}
				
				\item {\large قابلیت توسعه‌پذیری}:
				{\normalsize با ایجاد کتابخانه‌ها و بسته‌های متنوع، کاربران می‌توانستند قابلیت‌های \lr{R} را برای نیازهای خاص خود توسعه دهند.}
				
			\end{itemize}
			
		
		\section{مشکلاتی که در ابتدای ظهور خود رفع می‌کرد}
		
			\begin{itemize}
				
				\item {\large عدم دسترسی به ابزارهای پیشرفته تحلیل داده}:
				{\normalsize با ارائه ابزارهایی قدرتمند، نیاز به نرم‌افزارهای گران‌قیمت را کاهش داد.}
				
				\item {\large مصورسازی ضعیف داده‌ها}:
				{\normalsize در آن زمان، بسیاری از زبان‌های برنامه‌نویسی، ابزارهای گرافیکی مناسبی نداشتند. \lr{R} با کتابخانه‌هایی مثل \lr{ggplot2}، انقلابی در مصورسازی داده‌ها ایجاد کرد.}
				
				\item {\large پیچیدگی کدنویسی در زبان‌های عمومی}:
				{\normalsize تحلیل‌گران داده معمولاً نیاز داشتند تا با زبان‌هایی مثل \lr{Fortran} یا \lr{C} کار کنند که برای تحلیل داده بهینه نبودند. \lr{R} این مشکل را رفع کرد و کار با داده‌ها را ساده‌تر نمود.}
				
			\end{itemize}
			
		
		\section{بهبود نسبت به زبان‌های دیگر}
		
			\lr{R} بسیاری از قابلیت‌ها و ویژگی‌های موجود در زبان‌های دیگر را ارتقا داد و درون خود تجمیع کرد:
			
			\begin{itemize}
				
				\item {\large مقایسه با \lr{SAS}}:
				{\normalsize رایگان و متن‌باز بود، در حالی که \lr{SAS} یک نرم‌افزار تجاری بود.}
				
				\item {\large مقایسه با \lr{MATLAB}}:
				{\normalsize در تحلیل‌های آماری پیچیده کارآمدتر بود و به جامعه کاربری بزرگی در حوزه آمار متکی بود.}
				
				\item {\large مقایسه با \lr{Python} (در زمان آغاز)}:
				{\normalsize \lr{Python} در آن زمان بیشتر برای توسعه اسکریپت کاربرد داشت و قدرت تحلیل داده‌ای آن مثل امروز توسعه نیافته بود.}
				
			\end{itemize}
			
		
		\section{ویژگی‌های متمایز زبان}
			
			\begin{itemize}
				
				\item {\large تمرکز بر آمار}:
				{\normalsize برخلاف زبان‌های عمومی مثل \lr{Python} یا \lr{C++}، \lr{R} از ابتدا با هدف تحلیل آماری طراحی شده است.}
				
				\item {\large کتابخانه‌های تخصصی}:
				{\normalsize \lr{R} دارای بیش از 18,000 بسته تخصصی در حوزه‌های مختلف مانند ژنتیک، مالی، یادگیری ماشین و غیره است.}
				
				\item {\large مصورسازی پیشرفته}:
				{\normalsize \lr{R} ابزارهای قدرتمندی برای ایجاد نمودارهای پیچیده و تعاملی دارد که در مقایسه با زبان‌های مشابه، برجسته‌تر است.}
				
				\item {\large جامعه کاربری بزرگ}:
				{\normalsize جامعه \lr{R} بسیار فعال است و منابع یادگیری رایگان بسیاری فراهم کرده است.}
				
				\item {\large قابلیت‌های تعاملی}:
				{\normalsize با ابزارهایی مثل \lr{RStudio} و \lr{Shiny}، \lr{R} امکان ایجاد داشبوردها و برنامه‌های وب تعاملی را فراهم می‌کند.}
				
			\end{itemize}
			
			
		\section{ارزیابی بر اساس معیارهای مختلف}
			
			\begin{itemize}
				
				\item {\large خوانایی}:
				{\normalsize برای کاربران با پس‌زمینه آمار و علوم داده خواناتر است. با این حال، نحو خاص آن ممکن است برای برنامه‌نویسان سنتی دشوار باشد.}
				
				\item {\large قابلیت اطمینان}:
				{\normalsize در تحلیل‌های آماری و شبیه‌سازی‌ها بسیار قابل‌اعتماد است. با این حال، برای پروژه‌های بزرگ و داده‌های حجیم ممکن است نیاز به بهینه‌سازی داشته باشد.}
				
				\item {\large هزینه}:
				{\normalsize رایگان و متن‌باز است، که آن را به انتخابی ایده‌آل برای دانشجویان و شرکت‌های نوپا تبدیل می‌کند.}
				
				\item {\large بهره‌وری و کارایی}:
				{\normalsize برای تحلیل‌های آماری کوچک و متوسط، R بسیار سریع و کارآمد است. اما در مقایسه با زبان‌هایی مثل \lr{Python} برای پروژه‌های چندمنظوره یا داده‌های حجیم ممکن است کارایی کمتری داشته باشد.}
				
				\item {\large هزینه یادگیری}:
				{\normalsize برای کسانی که با آمار آشنایی دارند، آسان‌تر است. اما برای برنامه‌نویسان تازه‌کار، زبان‌هایی مثل \lr{Python} ساده‌تر هستند.}
				
				\item {\large قابلیت جابجایی}:
				{\normalsize بر روی تمامی سیستم‌عامل‌های رایج (ویندوز، مک، لینوکس) بدون مشکل اجرا می‌شود.}
				
				\item {\large ابزارهای توسعه}:
				{\normalsize ابزارهایی مانند \lr{RStudio} و \lr{Jupyter Notebook} پشتیبانی قدرتمندی برای توسعه و تحلیل داده ارائه شده‌اند‌.}
				
			\end{itemize}
			
		
		
		\section{مقایسه با زبان‌های مشابه}
		
									
			\subsection{خوانایی}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize طراحی شده با تمرکز بر آمار و تحلیل داده. کدهای R ممکن است برای تازه‌کاران کمی دشوار به نظر برسند، اما برای کسانی که در تحلیل آماری تجربه دارند، خوانا و ساده است.}
					
					\item {\large \lr{Python}}:
					{\normalsize خوانایی بالاتر به دلیل سینتکس ساده و عمومی. یادگیری و استفاده از آن برای افراد تازه‌کار آسان‌تر است.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize خوانا و ساده، مخصوصاً برای مهندسان. ساختار نوشتار آن شبیه به ریاضیات است.}
					
					\item {\large \lr{SAS}}:
					{\normalsize نسبتاً سخت‌تر به دلیل سینتکس خاص و قدیمی.}
					
				\end{itemize}
		
			\subsection{سادگی}
			
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize برای تحلیل داده ساده و بهینه است، اما سینتکس آن برای کارهای غیرتحلیلی ممکن است پیچیده باشد.}
					
					\item {\large \lr{Python}}:
					{\normalsize ساده‌تر به دلیل طراحی چندمنظوره و استفاده گسترده در زمینه‌های مختلف.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize ساده اما گران است، زیرا نیاز به لایسنس دارد.}
					
					\item {\large \lr{SAS}}:
					{\normalsize پیچیده‌تر، به خصوص برای کاربران غیرمتخصص.}
					
				\end{itemize}
				
				
			\subsection{کتابخانه‌ها}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize غنی‌ترین مجموعه کتابخانه‌های آماری و تحلیل داده را دارد (\lr{CRAN}، \lr{Bioconductor}).}
					
					\item {\large \lr{Python}}:
					{\normalsize دارای کتابخانه‌های عمومی قوی مانند \lr{Pandas}، \lr{NumPy}، و \lr{scikit-learn} است. اما برای تحلیل‌های پیشرفته، به \lr{R} نمی‌رسد.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize کتابخانه‌های ریاضی و شبیه‌سازی قوی دارد، اما برای تحلیل آماری گسترده نیست.}
					
					\item {\large \lr{SAS}}:
					{\normalsize ابزارهای تخصصی برای تحلیل داده دارد، اما کتابخانه‌های خارجی محدودند.}
					
				\end{itemize}

				
			\subsection{کاربرد}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize تحلیل داده، مدل‌سازی آماری، یادگیری ماشین.}
					
					\item {\large \lr{Python}}:
					{\normalsize همه‌منظوره، از تحلیل داده تا هوش مصنوعی و توسعه وب.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize محاسبات عددی، شبیه‌سازی و پردازش سیگنال.}
					
					\item {\large \lr{SAS}}:
					{\normalsize تحلیل داده‌های صنعتی و کسب‌وکاری.}
					
				\end{itemize}
				
				
				\subsection{کارایی}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize برای مجموعه داده‌های بزرگ ممکن است کند باشد مگر با استفاده از بسته‌های بهینه‌سازی شده.}
					
					\item {\large \lr{Python}}:
					{\normalsize سریع‌تر با کتابخانه‌هایی مانند \lr{NumPy} و استفاده از \lr{Cython}.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize کارایی بالا برای مسائل ریاضی و شبیه‌سازی.}
					
					\item {\large \lr{SAS}}:
					{\normalsize کارایی بالا در تحلیل داده‌های سازمانی.}
					
				\end{itemize}
				
				
				\subsection{هزینه}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize رایگان و متن‌باز.}
					
					\item {\large \lr{Python}}:
					{\normalsize رایگان و متن‌باز.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize بسیار گران و نیازمند لایسنس.}
					
					\item {\large \lr{SAS}}:
					{\normalsize گران‌قیمت و مناسب شرکت‌ها.}
					
				\end{itemize}
				
				
				\subsection{قدرت آماری}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize بالاترین قدرت آماری، با گسترده‌ترین ابزارها و مدل‌ها.}
					
					\item {\large \lr{Python}}:
					{\normalsize قدرت آماری متوسط. کتابخانه‌های آن برای تحلیل داده کافی هستند، اما به گستردگی \lr{R} نیستند.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize قدرت آماری کمتر نسبت به \lr{R} و \lr{Python}.}
					
					\item {\large \lr{SAS}}:
					{\normalsize قدرت آماری بالا، اما بیشتر در حوزه‌های سازمانی کاربرد دارد.}
					
				\end{itemize}
				
				
			\subsection{قابلیت جابجایی}
				
				\begin{itemize}
					
					\item {\large \lr{R}}:
					{\normalsize قابل نصب روی تمام سیستم‌عامل‌ها (\lr{Windows}، \lr{macOS} و \lr{Linux}).}
					
					\item {\large \lr{Python}}:
					{\normalsize بسیار قابل جابجایی با پشتیبانی جهانی.}
					
					\item {\large \lr{MATLAB}}:
					{\normalsize نیاز به لایسنس برای هر سیستم‌عامل.}
					
					\item {\large \lr{SAS}}:
					{\normalsize معمولاً به صورت سروری استفاده می‌شود و به راحتی قابل انتقال نیست.}
					
				\end{itemize}
				
			\subsection{نتیجه‌گیری}
				
				\begin{itemize}
					
					\item {\large اگر قدرت آماری و تحلیل داده اولویت است}:
					{\normalsize \lr{R} بهترین گزینه است.}
					
					\item {\large اگر نیاز به یک زبان همه‌منظوره با کاربری گسترده دارید}:
					{\normalsize \lr{Python} انتخاب بهتری است.}
					
					\item {\large اگر نیازمند به زبانی برای شبیه‌سازی هستید}:
					{\normalsize \lr{MATLAB} برتری دارد.}
					
					\item {\large اگر تحلیل‌های کسب‌وکاری سازمانی مدنظر است}:
					{\normalsize \lr{SAS} گزینه مناسبی است.}
					
				\end{itemize}
				
		\section{نوع پیاده‌سازی}
		
			\begin{itemize}
				
				\item {\large تفسیرشده}:
				{\normalsize \lr{R} به طور اصلی یک زبان تفسیرشده است، به این معنی که کدها به صورت خط به خط توسط مفسر اجرا می‌شوند. این قابلیت به تحلیل‌گران اجازه می‌دهد تا کدها را به صورت تعاملی اجرا کنند و سریعاً نتایج را ببینند.}
				
				\item {\large کامپایل جزئی (\lr{Just-in-Time Compilation})}:
				{\normalsize از نسخه 2.13 به بعد، \lr{R} از کامپایلر JIT\LTRfootnote{Just-in-Time} بهره می‌برد که با استفاده از بسته \lr{compiler} ارائه شده است. \lr{JIT} بهینه‌سازی‌هایی برای اجرای سریع‌تر کدها فراهم می‌کند.
				}
				
				\item {\large پیاده‌سازی ترکیبی}:
				{\normalsize اگرچه \lr{R} عمدتاً تفسیرشده است، برای برخی از عملیات‌های پیچیده‌تر، از کدهای \lr{C} و \lr{Fortran} استفاده می‌شود که کامپایل شده‌اند تا کارایی بیشتری داشته باشند.
				}
			\end{itemize}

		\section{مفسرها و کامپایلرهای موجود برای \lr{R}}
		
			\begin{enumerate}
				
				\item {\large \lr{GNU R} (\lr{R} پایه)}:
				
				\begin{itemize}
					
					\item  {\large توسعه‌دهنده}:
					{\normalsize تیم توسعه \lr{R} که یک گروه جهانی از متخصصان و دانشمندان داده است.}
					
					\item {\large ویژگی‌ها}:
					
					\begin{itemize}
						
						\item مفسر اصلی زبان \lr{R}.
						
						\item پیاده‌سازی به زبان \lr{C} و \lr{Fortran}.
						
						\item استفاده از بسته \lr{compiler} برای کامپایل جزئی.
						
					\end{itemize}
					
					\item {\large مزایا}:
					
					\begin{itemize}
						
						\item منبع‌باز و رایگان.
						
						\item پایدار و استاندارد، با پشتیبانی وسیع از جامعه کاربری.
						
					\end{itemize}
					
				\end{itemize}
				
				
				\item {\large \lr{FastR}}:
				
				\begin{itemize}
					
					\item  {\large توسعه‌دهنده}:
					{\normalsize تیم \lr{Oracle Labs} به عنوان بخشی از پروژه \lr{GraalVM}.}
					
					\item {\large ویژگی‌ها}:
					
					\begin{itemize}
						
						\item یک پیاده‌سازی جایگزین برای \lr{R} با هدف افزایش سرعت اجرا.
						
						\item از JIT برای اجرای سریع‌تر کدها بهره می‌برد.
						
					\end{itemize}
					
					\item {\large مزایا}:
					
					\begin{itemize}
						
						\item بهینه‌سازی برای کاربردهای داده‌های حجیم و عملکرد سریع‌تر نسبت به \lr{GNU R}.
						
						\item سازگاری با ابزارهای \lr{GraalVM}.
						
					\end{itemize}
					
				\end{itemize}
				
				
				\item {\large \lr{Renjin}}:
				
				\begin{itemize}
					
					\item  {\large توسعه‌دهنده}:
					{\normalsize BeDataDriven، یک شرکت هلندی.}
					
					\item {\large ویژگی‌ها}:
					
					\begin{itemize}
						
						\item پیاده‌سازی \lr{R} در \lr{JVM}\LTRfootnote{Java Virtual Machine}.
						
						\item مناسب برای ادغام با سیستم‌های مبتنی بر جاوا.
						
					\end{itemize}
					
					\item {\large مزایا}:
					
					\begin{itemize}
						
						\item کارایی بالا در محیط‌های سازمانی جاوا.
						
						\item امکان ادغام مستقیم با زیرساخت‌های جاوا.
						
					\end{itemize}
					
				\end{itemize}
				
				
				\item {\large \lr{pqR}}:
				
				\begin{itemize}
					
					\item  {\large توسعه‌دهنده}:
					{\normalsize \lr{Radford Neal}، یک آماردان برجسته.}
					
					\item {\large ویژگی‌ها}:
					
					\begin{itemize}
						
						\item یک نسخه بهینه‌شده از \lr{GNU R} با تمرکز بر اجرای سریع‌تر.
						
						\item بهره‌گیری از پردازش موازی برای بهبود کارایی.
						
					\end{itemize}
					
					\item {\large مزایا}:
					
					\begin{itemize}
						
						\item سرعت بالاتر برای تحلیل داده‌ها.
						
						\item مناسب برای کاربران حرفه‌ای تر.
						
					\end{itemize}
					
				\end{itemize}
				
				
				\item {\large \lr{Microsoft R Open (MRO)}}:
				
				\begin{itemize}
					
					\item  {\large توسعه‌دهنده}:
					{\normalsize مایکروسافت (\lr{Microsoft}).}
					
					\item {\large ویژگی‌ها}:
					
					\begin{itemize}
						
						\item نسخه بهینه‌شده R با بهبود عملکرد.
						
						\item شامل بسته‌های از پیش کامپایل‌شده و بهینه‌سازی شده برای تحلیل داده.
						
					\end{itemize}
					
					\item {\large مزایا}:
					
					\begin{itemize}
						
						\item یکپارچگی با ابزارهای مایکروسافت مانند \lr{Azure Machine Learning}.
						
						\item سرعت بیشتر در پردازش داده‌های حجیم.
						
					\end{itemize}
					
				\end{itemize}
				
			\end{enumerate}
			
			\begin{table}[h!]
				\centering
				\begin{tabular}{|c|p{5cm}|p{5cm}|}
					\hline
					\textbf{پیاده‌سازی} & \textbf{مزایا} & \textbf{معایب} \\ \hline
					\lr{GNU R} & استاندارد و قابل اعتماد، منبع‌باز، جامعه کاربری گسترده & سرعت پایین‌تر نسبت به نسخه‌های بهینه‌شده \\ \hline
					\lr{FastR} & سرعت بیشتر، سازگاری با \lr{GraalVM} & نیاز به پیکربندی پیشرفته \\ \hline
					\lr{Renjin} & سازگاری با جاوا، مناسب برای محیط‌های سازمانی & محدودیت در پشتیبانی برخی از بسته‌های \lr{R} \\ \hline
					\lr{pqR} & پردازش موازی، کارایی بالا & جامعه کاربری کوچک‌تر \\ \hline
					\lr{Microsoft R Open} & سازگاری با ابزارهای مایکروسافت، سرعت بیشتر & وابستگی به اکوسیستم مایکروسافت \\ \hline
				\end{tabular}
				\caption{مقایسه پیاده‌سازی‌های مختلف زبان R}
				\label{table:r_implementations}
			\end{table}
			
	
	
	\chapter{نحو و معنا شناسی}
	
		\section{نحو و معناشناسی}
		
			کلمات کلیدی زبان \lr{R} شامل موارد زیر است و نمی‌توان از آن‌ها به عنوان نام متغیر یا تابع استفاده کرد:
			\lr{if}، \lr{else}، \lr{repeat}، \lr{while}، \lr{function}، \lr{for}، \lr{in}، \lr{next}، \lr{break}، \lr{TRUE}، \lr{FALSE}، \lr{NULL}، \lr{NA}، \lr{Inf}، \lr{NaN}، \lr{NA\_integer\_}، \lr{NA\_real\_}، \lr{NA\_complex\_} و \lr{NA\_character\_}
			
			توضیح کلمات کلیدی:
			
			\subsection{\lr{if} - اجرای کد بر اساس شرط مشخص}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{if}}]
if (x > 0) {
	print("is positive")
}
					\end{lstlisting}
				\end{latin}
			
			\subsection{\lr{else} - بلوک جایگزین در صورت عدم تحقق شرط}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{else}}]
if (x > 0) {
	print("is positive")
} else {
	print("is negative or zero")
}
					\end{lstlisting}
				\end{latin}
				
			\subsection{\lr{repeat} - اجرای حلقه بی‌نهایت تا زمان استفاده از \lr{break}}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{repeat}}]
i <- 1
repeat {
	print(i)
	if (i == 5) break
	i <- i + 1
}
					\end{lstlisting}
				\end{latin}
				
				
			\subsection{\lr{while} - اجرای حلقه تا زمانی که شرط برقرار باشد}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{while}}]
i <- 1
while (i <= 5) {
	print(i)
	i <- i + 1
}
					\end{lstlisting}
				\end{latin}
				
			\subsection{\lr{function} - تعریف توابع جدید}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{function}}]
my_function <- function(a, b) {
	return(a + b)
}
print(my_function(3, 4))
					\end{lstlisting}
				\end{latin}
				
				
			\subsection{\lr{for} - اجرای حلقه روی مجموعه‌ای از مقادیر}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{for}}]
for (i in 1:5) {
	print(i)
}
					\end{lstlisting}
				\end{latin}
				
							
			\subsection{\lr{in} - تعیین عضویت یا استفاده در حلقه}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{in}}]
x <- 5
print(x %in% c(3, 5, 7)) # output: TRUE
					\end{lstlisting}
				\end{latin}				
				
			\subsection{\lr{next} - عبور از مرحله جاری و رفتن به مرحله بعدی حلقه}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{next}}]
for (i in 1:5) {
	if (i == 3) next
	print(i)
}
					\end{lstlisting}
				\end{latin}	
				
			\subsection{\lr{break} - خروج از حلقه}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{break}}]
for (i in 1:5) {
	if (i == 3) break
	print(i)
}
					\end{lstlisting}
				\end{latin}	
	
			\subsection{\lr{TRUE}و \lr{FALSE} - مقادیر منطقی \lr{(Boolean)} در \lr{R}}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{TRUE, FALSE}}]
x <- TRUE
y <- FALSE
print(x & y) # output: FALSE
					\end{lstlisting}
				\end{latin}
				
			\subsection{\lr{NULL} - نشان‌دهنده مقدار خالی یا بدون مقدار}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{NULL}}]
x <- NULL
print(is.null(x)) # output: TRUE
					\end{lstlisting}
				\end{latin}
			
			\subsection{\lr{NA} - مقدار غیرموجود یا ناشناخته \lr{(Not Available)}}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{NA}}]
x <- c(1, NA, 3)
print(is.na(x)) # output: FALSE TRUE FALSE
					\end{lstlisting}
				\end{latin}
				
			\subsection{\lr{Inf} و \lr{-Inf} - مقدار بی‌نهایت مثبت و منفی}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{Inf, -Inf}}]
print(1 / 0) # output: Inf
print(-1 / 0) # output: -Inf
					\end{lstlisting}
				\end{latin}
				
			\subsection{\lr{NaN} - عدد غیرقابل تعریف \lr{(Not a Number)}}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{NaN}}]
print(0 / 0) # output: NaN
					\end{lstlisting}
				\end{latin}
				
			\subsection{\lr{NA\_integer\_}، \lr{NA\_real\_}، \lr{NA\_complex\_} و \lr{NA\_character\_} - انواع خاص \lr{NA} برای داده‌های مختلف}
				\begin{latin}
					\begin{lstlisting}[caption={\lr{NA\_integer\_, NA\_real\_, NA\_complex\_, NA\_character\_}}]
x <- NA_integer_
print(typeof(x)) # output: integer
					\end{lstlisting}
				\end{latin}
				
				
				
		\section{گرامر ساده برای بخشی از زبان}
			
			گرامر زیر یک زیرمجموعه کوچک از \lr{R} را برای ساختارهای کنترلی و عملیات ریاضی توصیف می‌کند:
			
		
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Simple R grammar}}]
<program>       ::= <statement> | <statement> ";" <program>
<statement>     ::= <assignment> | <conditional> | <loop> | <expression>
<assignment>    ::= <identifier> "<-" <expression>
<conditional>   ::= "if" "(" <expression> ")" "{" <program> "}" [ "else" "{" <program> "}" ]
<loop>          ::= "for" "(" <identifier> "in" <expression> ")" "{" <program> "}" 
<expression>    ::= <term> | <term> <operator> <expression>
<term>          ::= <number> | <identifier> | "(" <expression> ")"
<operator>      ::= "+" | "-" | "*" | "/"
<number>        ::= [0-9]+
<identifier>    ::= [a-zA-Z_][a-zA-Z0-9_]*

				\end{lstlisting}
			\end{latin}
				
				
			\section{برنامه نمونه در زبان}  \label{Simple_R_program}
			
				برنامه زیر یک حلقه برای محاسبه مجموع اعداد 1 تا 10 است:
				
				\begin{latin}
					\begin{lstlisting}[caption={\lr{Simple R program}}] 
sum <- 0
for (i in 1:10) {
	sum <- sum + i
}
print(sum)
						
					\end{lstlisting}
				\end{latin}
				
				
			\section{درخت تجزیه برای برنامه نمونه}
				درخت تجزیه برنامه \ref{Simple_R_program} شامل عناصر زیر است:
				
				\begin{latin}
					\begin{forest}
						[
							Program
								[Assignment [sum <- 0]]
								[For Loop
									[Identifier [i]]
									[Range [1:10]]
									[Body
										[Assignment [sum <- sum + i]]
									]
								]
								[Print
									[Identifier [sum]]
								]
						]
					\end{forest}
				\end{latin}


		\section{تقدم و وابستگی عملگرها}
			
			در \lr{R}، تقدم عملگرها به صورت پیش‌فرض تعریف شده است. برخی از عملگرهای رایج با ترتیب تقدم:
			
			\begin{enumerate}
				
				\item {\large داخل پرانتز - ()}:
				{\normalsize بالاترین تقدم.}
				
				\item {\large توابع}:
				{\normalsize توابع مانند \lr{sin()}, \lr{log()} تقدم بیشتری از عملگرهای ریاضی دارند.}
				
				\item {\large عملگر توان}:
				{\normalsize بیشترین تقدم میان عملگرهای ریاضی.}
				
				\item {\large ضرب و تقسیم - (* و /)}:
				{\normalsize بالاتر از جمع و تفریق.}
				
				\item {\large جمع و تفریق - (+ و -)}:
				{\normalsize پایین‌تر از ضرب و تقسیم.}
				
			\end{enumerate}
			
			{\Large وابستگی عملگرها:}
			
			\begin{itemize}
				
				\item بیشتر عملگرها از چپ به راست ارزیابی می‌شوند (مثلاً +, -, *, /).
				
				\item عملگر توان از راست به چپ ارزیابی می‌شود.
				
			\end{itemize}
			
			
			{\Large مثال:}
			
				\begin{latin}
					\begin{lstlisting}[caption={\lr{Precedence of operators}}] 
x <- 2 + 3 * 4^2
						
					\end{lstlisting}
				\end{latin}
				
				توضیح گام به گام:
				
				\begin{enumerate}
					
					\item 
					توان: $4^2 = 16$.
					
					\item 
					ضرب: $3 * 16 = 48$.
					
					\item
					جمع: $2 + 48 = 50$.
					
				\end{enumerate}
				
				
		\section{توصیف گرامر بر اساس تقدم عملگرها}
			
			برای پیروی از تقدم عملگرها در گرامر، می‌توانیم گرامر را اصلاح کنیم:
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Operation grammar}}] 
<expression> ::= <term> | <term> "+" <expression> | <term> "-" <expression>
<term>       ::= <factor> | <factor> "*" <term> | <factor> "/" <term>
<factor>     ::= <number> | "(" <expression> ")" | <factor> "^" <factor>

				\end{lstlisting}
			\end{latin}
			
			این گرامر تقدم توان را بالاتر از ضرب و تقسیم و تقدم ضرب و تقسیم را بالاتر از جمع و تفریق تضمین می‌کند.
				
				
				
		\section{معناشناسی عملیاتی و توصیف ساختارها}
		
			مقایسه برخی از ساختارهای پایه در زبان‌های برنامه نویسی در زبان‌های \lr{R}، \lr{C} و اسمبلی:
			
			\subsection{تخصیص (\lr{Assignment})}
			
				\begin{itemize}
					
					\item کد \lr{R}
					\begin{latin}
						\begin{lstlisting}[caption={\lr{R Assignment}}] 
sum <- 0
							
						\end{lstlisting}
					\end{latin}
					
					\item معادل در \lr{C}
					\begin{latin}
						\begin{lstlisting}[caption={\lr{C Assignment}}] 
int sum = 0;

						\end{lstlisting}
					\end{latin}
					
					\item معادل در اسمبلی (فرض پردازنده \lr{x86})
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Assembly Assignment}}] 
MOV sum, 0

						\end{lstlisting}
					\end{latin}
					
				\end{itemize}
				
				
			\subsection{حلقه \lr{for}}
				
				\begin{itemize}
					
					\item کد \lr{R}
					\begin{latin}
						\begin{lstlisting}[caption={\lr{R for}}] 
for (i in 1:10) {
	sum <- sum + i
}
							
						\end{lstlisting}
					\end{latin}
					
					\item معادل در \lr{C}
					\begin{latin}
						\begin{lstlisting}[caption={\lr{C for}}] 
for (int i = 1; i <= 10; i++) {
	sum += i;
}
							
						\end{lstlisting}
					\end{latin}
					
					\item معادل در اسمبلی
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Assembly loop}}] 
MOV i, 1
MOV sum, 0
LOOP_START:
ADD sum, i
INC i
CMP i, 10
JLE LOOP_START
							
						\end{lstlisting}
					\end{latin}
					
				\end{itemize}
								
				
			\subsection{چاپ (\lr{Print})}
				
				\begin{itemize}
					
					\item کد \lr{R}
					\begin{latin}
						\begin{lstlisting}[caption={\lr{R Print}}] 
print(sum)

						\end{lstlisting}
					\end{latin}
					
					\item معادل در \lr{C}
					\begin{latin}
						\begin{lstlisting}[caption={\lr{C Print}}] 
printf("%d", sum);

						\end{lstlisting}
					\end{latin}
					
				\end{itemize}
	
	\chapter{متغیرها و نوع های داده ای}
	
		\section{انقیاد}
		
			\subsection{انقیاد نوع و مقدار}
			
				\subsubsection{انقیاد نوع (\lr{Type Binding})}
				
					نوع‌گذاری پویا (\lr{Dynamic Typing}): در \lr{R}، متغیرها نیازی به تعریف نوع در زمان اعلان ندارند. نوع متغیر در زمان اختصاص مقدار (\lr{assignment}) تعیین می‌شود.
					این نوع‌گذاری به صورت زمان اجرا (\lr{Runtime}) انجام می‌شود.
					نوع متغیر می‌تواند در طول برنامه تغییر کند.
					
					
					مثال:
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Type Binding}}] 
x <- 42       # integer
x <- "Hello"  # character
							
						\end{lstlisting}
					\end{latin}
					
					در این مثال، متغیر \lr{x} ابتدا یک عدد صحیح (\lr{integer}) است، اما بعداً به یک مقدار رشته‌ای (\lr{character}) تغییر می‌یابد. این نشان‌دهنده نوع‌گذاری پویا است.
					
				\subsection{انقیاد مقدار (\lr{Value Binding})}
				
					مقداردهی متغیرها در زمان تخصیص مقدار به متغیر انجام می‌شود. از عملگر <- یا = برای اختصاص مقدار به متغیر استفاده می‌شود.
					انقیاد مقدار در \lr{R} در زمان اجرا (\lr{Runtime}) انجام می‌شود، زیرا مقادیر می‌توانند تغییر کنند.
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Value Binding}}] 
y <- 10          # Initialization
y <- y + 5       # New value

						\end{lstlisting}
					\end{latin}
					
					در این مثال، مقدار \lr{y} ابتدا 10 است و بعداً به 15 تغییر می‌کند.

			\subsection{تعریف متغیرها}
				{\large صریح یا ضمنی بودن تعاریف}:
				در زبان R، تعاریف متغیرها می‌توانند صریح (\lr{Explicit}) یا ضمنی (\lr{Implicit}) باشند.
				
				\subsubsection{تعریف صریح}
				
					متغیرها به وضوح توسط کاربر تعریف می‌شوند.
					از عملگر تخصیص (<- یا =) برای این کار استفاده می‌شود.
						\begin{latin}
							\begin{lstlisting}[caption={\lr{Explicit Variable}}] 
my_var <- 20

							\end{lstlisting}
						\end{latin}
						
				\subsubsection{تعریف ضمنی}
					برخی اشیاء در \lr{R} به صورت ضمنی در زمان استفاده از آنها تعریف می‌شوند، مثلاً در توابع.
					
						\begin{latin}
							\begin{lstlisting}[caption={\lr{Implicit Variable}}] 
for (i in 1:5) {
	print(i)
}
								
							\end{lstlisting}
						\end{latin}
						
						در اینجا متغیر \lr{i} بدون تعریف صریح، به طور خودکار در حلقه \lr{for} تعریف می‌شود.

			\subsection{تاثیر پویا بودن انقیاد نوع و مقدار}
				
				انعطاف‌پذیری زبان \lr{R} به دلیل انقیاد پویا امکان تعریف متغیرها بدون در نظر گرفتن نوع را فراهم می‌کند، اما ممکن است خطاهای نوع (\lr{type error}) را در زمان اجرا افزایش دهد.
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Type error}}] 
x <- 10
x <- x + "5"   # Error: Unable to add number and string.

						\end{lstlisting}
					\end{latin}
			
			\subsection{کاربرد و مزایا}
				
				\begin{itemize}
					
					\item {\large انعطاف‌پذیری}:
					{\normalsize مناسب برای تحلیل داده و کدنویسی سریع.}
					
					\item {\large سادگی}:
					{\normalsize نیاز به تعریف دقیق نوع و مقدار ندارد.}
					
					\item {\large کاهش پیچیدگی}:
					{\normalsize مناسب برای کاربران غیر برنامه‌نویس (مانند تحلیل‌گران داده).}
					
				\end{itemize}
				
			
			\subsection{نتیجه‌گیری}
				
				
				در زبان \lr{R}:
			
				\begin{enumerate}
					
					\item انقیاد نوع و مقدار به صورت پویا و در زمان اجرا (\lr{Runtime}) انجام می‌شود.
					
					\item تعاریف متغیرها می‌توانند صریح (با تخصیص مقدار) یا ضمنی (در توابع یا ساختارهای کنترلی) باشند.
					
					\item انعطاف‌پذیری انقیاد نوع و مقدار، \lr{R} را به زبانی ساده و مناسب برای تحلیل داده و آزمایش سریع ایده‌ها تبدیل کرده است.
					
				\end{enumerate}
		
		\section{بررسی انواع متغیرها}
		
			\subsection{متغیرهای ایستا (\lr{Static Variables})}
				در زبان \lr{R}، متغیرهای ایستا به صورت صریح وجود ندارند. با این حال، متغیرهایی که خارج از بدنه توابع تعریف می‌شوند (مانند متغیرهای سراسری)، ممکن است به صورت ایستا در نظر گرفته شوند. این متغیرها در طول اجرای برنامه در حافظه باقی می‌مانند. مثال:
				
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Static variables}}] 
global_var <- 100  # Global variable

my_function <- function() {
	print(global_var)  # Access to a global variable
}

my_function()
		
						\end{lstlisting}
					\end{latin}
					
					\begin{itemize}
						
						\item 
						{\large پیاده‌سازی}
						
						
						این متغیرها در فضایی به نام محیط جهانی (\lr{Global Environment}) ذخیره می‌شوند.
						محیط جهانی در طول اجرای برنامه فعال است و متغیرها تا زمانی که برنامه در حال اجرا باشد، باقی می‌مانند.
						
						\item 
						{\large سرعت تخصیص}
						
						
						متغیرهای ایستا سریع‌تر از متغیرهای پویا تخصیص داده می‌شوند، زیرا در آغاز اجرا تخصیص می‌یابند.
						
					\end{itemize}
			
			\subsection{متغیرهای پویا در پشته (\lr{Dynamic Stack Variables})}
				
				متغیرهای تعریف‌شده داخل توابع، معمولاً در پشته ذخیره می‌شوند. این متغیرها فقط در طول اجرای تابع معتبر هستند. مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Dynamic stack variables}}] 
my_function <- function() {
	local_var <- 10  # Local variable
	print(local_var)
}

my_function()
# Unreachable error outside the function
# print(local_var)

						\end{lstlisting}
					\end{latin}
					
					\begin{itemize}
					
					\item 
					{\large پیاده‌سازی}
					
					
					این متغیرها در محیط تابع (\lr{Function Environment}) ذخیره می‌شوند که در پشته مدیریت می‌شود.
					زمانی که تابع تمام می‌شود، محیط آن نیز از بین می‌رود.
					
					
					\item 
					{\large سرعت تخصیص}
					
					
					تخصیص در پشته سریع است، زیرا فقط به تغییر اشاره‌گر پشته نیاز دارد.
					آزادسازی حافظه نیز خودکار و سریع انجام می‌شود.
					
					\end{itemize}
				
				
			
			\subsection{متغیرهای پویا در هیپ به طور صریح}
			
				در \lr{R}، هرگاه متغیری مانند یک بردار، لیست یا داده‌ای بزرگ تعریف شود، این متغیرها در هیپ ذخیره می‌شوند. کاربر به طور مستقیم از تخصیص حافظه آگاه نیست، اما تخصیص هیپ توسط مفسر \lr{R} انجام می‌شود. مثال:
				
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Dynamic variables on heap explicitly}}] 
large_vector <- rep(1, 1e6)  # Large vector
print(object.size(large_vector))  # Check the size at the heap
							
						\end{lstlisting}
					\end{latin}
					
					\begin{itemize}
						
						\item 
						{\large پیاده‌سازی}
						
						
						هیپ در R برای تخصیص حافظه اشیاء بزرگ‌تر و پیچیده‌تر (مانند بردارها و لیست‌ها) استفاده می‌شود.
						مدیریت حافظه از طریق جمع‌آوری زباله (\lr{Garbage Collection}) انجام می‌شود.
						
						
						\item 
						{\large سرعت تخصیص}
						
						
						تخصیص هیپ نسبت به پشته کندتر است، زیرا شامل درخواست‌های پیچیده‌تر از سیستم‌عامل و جمع‌آوری زباله است.
						
					\end{itemize}
			
			\subsection{متغیرهای پویا در هیپ به طور ضمنی}
			
				این نوع تخصیص زمانی رخ می‌دهد که \lr{R} به صورت خودکار برای متغیرهای کوچک یا موقتی نیز از هیپ استفاده کند. برای مثال، مقادیری که در عملیات‌های موقتی ایجاد می‌شوند. مثال:
				
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Dynamic variables on heap implicitly}}] 
result <- sum(1:100)  # Create a temporary value for the range
print(result)

						\end{lstlisting}
					\end{latin}
					
					\begin{itemize}
						
						\item 
						{\large پیاده‌سازی}
						
						
						\lr{R} ممکن است برای مقادیر موقتی نیز حافظه‌ای در هیپ تخصیص دهد، اما این حافظه به سرعت پس از استفاده آزاد می‌شود.
						
						
						\item 
						{\large سرعت تخصیص}
						
						
						سرعت این تخصیص نسبت به تخصیص مستقیم در پشته کمتر است، اما \lr{R} از بهینه‌سازی برای کاهش تاثیر عملکرد استفاده می‌کند.
						
					\end{itemize}
				
			
			\subsection{مقایسه انواع متغیر}
				\begin{table}[h!]
					\centering
					\begin{tabular}{|c|c|p{5cm}|}
						\hline
						\textbf{نوع تخصیص} & \textbf{سرعت تخصیص} & \textbf{دلایل} \\ \hline
						ایستا (Static) & بسیار سریع & تخصیص در زمان شروع برنامه انجام می‌شود. \\ \hline
						پویا در پشته (Stack) & سریع & مدیریت ساده با تغییر اشاره‌گر پشته. \\ \hline
						پویا در هیپ (Heap) & متوسط تا کند & نیاز به درخواست‌های سیستم‌عامل و مدیریت زباله. \\ \hline
						هیپ ضمنی (Implicit Heap) & کندتر & پیچیدگی در تخصیص موقت و آزادسازی سریع. \\ \hline
					\end{tabular}
					\caption{مقایسه انواع تخصیص و سرعت آن‌ها}
					\label{table:allocation_speeds}
				\end{table}
				
				
			\subsection{نتیجه‌گیری}
				زبان \lr{R} بیشتر از تخصیص پویا در هیپ استفاده می‌کند، اما تخصیص پشته نیز برای متغیرهای محلی وجود دارد. سرعت تخصیص متغیرها به نوع تخصیص و پیچیدگی اشیاء بستگی دارد. برای داده‌های کوچک و ساده، پشته سریع‌ترین گزینه است، در حالی که برای داده‌های بزرگ یا پیچیده، هیپ استفاده می‌شود که کندتر است. \lr{R} با استفاده از جمع‌آوری زباله و بهینه‌سازی داخلی، تاثیر کندی تخصیص در هیپ را کاهش می‌دهد.
				
			
		\section{حوزه‌های تعریف زبان}
		
			\subsection{حوزه تعریف ایستا (\lr{Static Scope})}
			
				در حوزه ایستا، متغیرها بر اساس محل تعریف‌شان در کد (نه محل فراخوانی) تعیین می‌شوند.
				\lr{R} از این نوع حوزه تعریف پشتیبانی می‌کند.
				وقتی یک متغیر در داخل یک تابع تعریف نشده باشد، \lr{R} به محیط لغوی تابع نگاه می‌کند (محیطی که تابع در آن تعریف شده است) و متغیر را از آنجا می‌گیرد. مثال حوزه ایستا:
				
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Static scope}}] 
x <- 10  # variable in the global environment

outer_function <- function() {
	inner_function <- function() {
		return(x)  # x takes from the lexical environment
	}
	return(inner_function())
}

print(outer_function())  # output: 10

						\end{lstlisting}
					\end{latin}
					
					در این مثال، متغیر \lr{x} در محیط جهانی تعریف شده است و تابع \lr{inner\_function} آن را بر اساس محیط لغوی تابع پیدا می‌کند.
			
			\subsection{حوزه تعریف پویا (Dynamic Scope)}
			
				در حوزه پویا، متغیرها بر اساس محل فراخوانی تابع (نه محل تعریف) تعیین می‌شوند.
				\lr{R} به طور پیش‌فرض این نوع حوزه را پشتیبانی نمی‌کند، اما می‌توان آن را با استفاده از ویژگی‌های مدیریت محیط‌ها (مانند \lr{parent.frame()} یا \lr{assign()}) شبیه‌سازی کرد. مثال:
			
			
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Dynamic scope}}] 
dynamic_function <- function() {
	print(x)  # x takes from the calling environment
}

caller_function <- function() {
	x <- 20  # Define x in this environment
	dynamic_function()
}

caller_function()  # output: 20

						\end{lstlisting}
					\end{latin}
					در این مثال، با استفاده از ویژگی‌های محیط، رفتار حوزه پویا شبیه‌سازی شده است.
					
			\subsection{افزودن حوزه پویا به زبان \lr{R}}
				
				اگر بخواهیم حوزه پویا را به \lr{R} اضافه کنیم، باید تغییرات زیر اعمال شود:
				
				\begin{enumerate}
					
					\item 
					{\large مدیریت محیط اجرا (\lr{Execution Environment})}
					
					
					به جای استفاده از محیط لغوی، تابع باید به محیط فراخوانی دسترسی داشته باشد.
					این کار با تغییر نحوه ذخیره و جستجوی متغیرها در محیط‌ها ممکن می‌شود.
					
					\item
					{\large پیاده‌سازی نمونه}
					
					
					برای شبیه‌سازی این تغییر، می‌توان از یک مفسر اصلاح‌شده یا تابعی کمکی استفاده کرد.
					
				\end{enumerate}
				
				نمونه کد برای حوزه پویا:
				
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Adding a dynamic scope to R}}] 
dynamic_scope <- function() {
	print(x)  # Gets x from the calling environment
}

caller_function <- function() {
	x <- 30  # Define x in the calling environment
	evalq(dynamic_scope(), envir = environment())  # Function execution in the calling environment
}

caller_function()  # output: 30

						\end{lstlisting}
					\end{latin}
				در اینجا، با استفاده از \lr{evalq()} و انتقال محیط، رفتار حوزه پویا شبیه‌سازی شده است.
					
			
			\subsection{پشتیبانی از هر دو نوع حوزه در \lr{R}}
			
				\lr{R} به طور مستقیم فقط حوزه ایستا دارد.
				حوزه پویا را می‌توان با استفاده از محیط‌های پویا (مانند \lr{parent.frame()} یا \lr{evalq()}) شبیه‌سازی کرد.
			
			\subsection{بلوک‌ها و کلمات کلیدی حوزه در \lr{R}}
				
				در \lr{R}، بلوک‌ها با استفاده از {} تعریف می‌شوند.
				هیچ کلمه کلیدی خاصی برای تغییر مستقیم حوزه تعریف وجود ندارد، اما می‌توان با استفاده از توابع مدیریتی مانند \lr{assign()}، \lr{environment()}، \lr{parent.frame()} و \lr{eval()} به صورت ضمنی حوزه را تغییر داد. مثال بلوک:
				\begin{latin}
					\begin{lstlisting}[caption={\lr{Blocks in R}}] 
{
	y <- 50
	print(y)
}
# y is not available outside the block
# print(y)  # Error: object 'y' not found

					\end{lstlisting}
				\end{latin}
				
			\subsection{نتیجه‌گیری}
			
				\begin{itemize}
					
					\item {\large حوزه ایستا}:
					{\normalsize \lr{R} به طور پیش‌فرض از این نوع استفاده می‌کند و متغیرها را از محیط تعریف پیدا می‌کند.}
					
					\item {\large حوزه پویا}:
					{\normalsize پشتیبانی مستقیم وجود ندارد، اما می‌توان آن را شبیه‌سازی کرد.	}
					
					\item {\large بلوک‌ها}:
					{\normalsize ر \lr{R} با {} تعریف می‌شوند و هیچ کلمه کلیدی خاصی برای مدیریت حوزه وجود ندارد، اما توابع محیطی می‌توانند حوزه را به طور غیرمستقیم تغییر دهند.}
					
				\end{itemize}
			
		\section{نوع‌های داده‌ای}
			
			\subsection{نوع‌های داده‌ای پایه (\lr{Basic Data Types})}
				
				زبان \lr{R} از انواع داده‌ای مختلفی پشتیبانی می‌کند که برای تحلیل داده‌ها، محاسبات آماری، و کار با داده‌های پیچیده طراحی شده‌اند. در اینجا، تمامی انواع داده‌ای در \lr{R}، نحوه تخصیص آنها در حافظه، پیاده‌سازی، و ویژگی‌های هرکدام توضیح می‌دهیم:
			
				\subsubsection{منطقی (\lr{Logical})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize \lr{TRUE}, \lr{FALSE}, یا \lr{NA} (عدم مقدار)}
						
						\item {\large کاربرد}:
						{\normalsize برای شرط‌ها و عملگرهای بولی.}
						
						\item {\large عملگرها}:
						{\normalsize \& (\lr{AND})، | (\lr{OR})، ! (\lr{NOT}).}
						
						\item {\large تخصیص در حافظه}:
						{\normalsize معمولاً به صورت ۱ بیت یا بیشتر برای ذخیره مقدار منطقی.}
						
					\end{itemize}
					
					مثال:
						\begin{latin}
							\begin{lstlisting}[caption={\lr{Logical data type}}] 
x <- TRUE
y <- FALSE
z <- x & y  # FALSE

							\end{lstlisting}
						\end{latin}
					
				
				\subsubsection{عددی (\lr{Numeric})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  .مقادیر عددی (شامل مقادیر اعشاری)}
						
						\item {\large کاربرد}:
						{\normalsize محاسبات ریاضی و آماری.}
						
						\item {\large عملگرها}:
						{\normalsize +, -, *, /, توان، \lr{\%\%} (باقیمانده).}
						
						\item {\large تخصیص در حافظه}:
						{\normalsize به صورت پیش‌فرض ۸ بایت (64 بیت) برای هر مقدار.}
						
					\end{itemize}
					
					مثال:

					\begin{latin}
						\begin{lstlisting}[caption={\lr{Numeric data type}}] 
a <- 3.14
b <- 2
result <- a + b  # 5.14

						\end{lstlisting}
					\end{latin}
				
				\subsubsection{عدد صحیح (\lr{Integer})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  شامل مقادیر عددی صحیح.}
						
						\item {\large کاربرد}:
						{\normalsize شمارنده‌ها و محاسبات عدد صحیح.}
						
						\item {\large ایجاد مقدار}:
						{\normalsize با استفاده از \lr{L} پس از عدد.}
						
						\item {\large تخصیص در حافظه}:
						{\normalsize ۴ بایت (32 بیت).}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Integer data type}}] 
int_val <- 5L
typeof(int_val)  # "integer"

						\end{lstlisting}
					\end{latin}
				
				\subsubsection{رشته‌ای (\lr{Character})}
					
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  شامل مقادیر متنی.}
						
						\item {\large کاربرد}:
						{\normalsize پردازش رشته‌ها، نام‌گذاری، و تحلیل متن.}
						
						\item {\large عملگرها}:
						{\normalsize الحاق (\lr{paste} و \lr{paste0}).}
						
						\item {\large تخصیص در حافظه}:
						{\normalsize به صورت آرایه‌ای از کاراکترها با طول متغیر.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Character data type}}] 
str <- "Hello"
full_str <- paste(str, "World")  # "Hello World"

						\end{lstlisting}
					\end{latin}
				
				\subsubsection{مختلط (\lr{Complex})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  شامل مقادیر مختلط (a + bi).}
						
						\item {\large کاربرد}:
						{\normalsize محاسبات ریاضی پیشرفته.}
						
						\item {\large عملگرها}:
						{\normalsize جمع، تفریق، ضرب، تقسیم.}
						
						\item {\large تخصیص در حافظه}:
						{\normalsize شامل دو مقدار عددی برای بخش حقیقی و موهومی.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Complex data type}}] 
comp <- 3 + 2i
Im(comp)  # 2

						\end{lstlisting}
					\end{latin}
				
			\subsection{ساختارهای داده‌ای پیچیده (\lr{Advanced Data Structures})}
			
				\subsubsection{بردار (\lr{Vector})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  مجموعه‌ای از مقادیر همگن.}
						
						\item {\large کاربرد}:
						{\normalsize تحلیل داده و آرایه‌های یک‌بعدی.}
						
						\item {\large عملگرها}:
						{\normalsize \lr{length}‌ و [ ] برای دسترسی.}
						
						\item {\large پیاده‌سازی}:
						{\normalsize به صورت آرایه در حافظه.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Vector data type}}] 
vec <- c(1, 2, 3)
vec[1]  # 1

						\end{lstlisting}
					\end{latin}
				
				
				
				\subsubsection{ماتریس (\lr{Matrix})}
					
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  آرایه‌ای دوبعدی از مقادیر همگن.}
						
						\item {\large کاربرد}:
						{\normalsize محاسبات ماتریسی.}
						
						\item {\large پیاده‌سازی}:
						{\normalsize به صورت آرایه دوبعدی.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Matrix data type}}] 
mat <- matrix(1:6, nrow=2)
mat[1, 2]  # 3

						\end{lstlisting}
					\end{latin}
				
				
				
				\subsubsection{لیست (\lr{List})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  شامل مقادیر ناهمگن.}
						
						\item {\large کاربرد}:
						{\normalsize ذخیره ساختارهای پیچیده.}
						
						\item {\large پیاده‌سازی}:
						{\normalsize اشاره‌گرهایی به مقادیر مختلف در حافظه.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{List data type}}] 
lst <- list(num=1, txt="Hello", vec=c(1,2,3))
lst$num  # 1

						\end{lstlisting}
					\end{latin}
				
				\subsubsection{چارچوب داده (\lr{Data Frame})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  ساختاری جدولی برای داده.}
						
						\item {\large کاربرد}:
						{\normalsize ساختاری جدولی برای داده.}
						
						\item {\large پیاده‌سازی}:
						{\normalsize به صورت لیست با ستون‌های هم‌طول.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Data Frame data type}}] 
df <- data.frame(A=c(1,2), B=c("X", "Y"))
df$A  # ستون A

						\end{lstlisting}
					\end{latin}
				
				\subsubsection{آرایه (\lr{Array})}
				
					\begin{itemize}
						
						\item {\large مقادیر}:
						{\normalsize  آرایه چندبعدی از مقادیر همگن.}
						
						\item {\large کاربرد}:
						{\normalsize محاسبات چندبعدی.}
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Array data type}}] 
arr <- array(1:8, dim=c(2,2,2))
arr[1,1,1]  # 1

						\end{lstlisting}
					\end{latin}
				
			\subsection{اشاره‌گرها و متغیرهای مرجع}
				
				\lr{R} به طور مستقیم اشاره‌گرها را در اختیار کاربر قرار نمی‌دهد.
				تمامی اشیاء در \lr{R} به صورت مرجع‌محور (\lr{Reference-Based}) مدیریت می‌شوند.
				عملگر \lr{address()} برای بررسی مکان حافظه استفاده می‌شود.
		
			\subsection{بازیافت حافظه (Garbage Collection)}
			
				\lr{R} از یک جمع‌آوری زباله (\lr{Garbage Collector}) استفاده می‌کند.
				
				\begin{itemize}
					
					\item {\large پیاده‌سازی}:
					{\normalsize از روش‌های ردیابی و شمارش مرجع برای آزادسازی حافظه اشیاء استفاده می‌شود.}
					
					\item {\large عملگر}:
					{\normalsize \lr{gc()} برای اجرای دستی جمع‌آوری زباله.}
					
				\end{itemize}
		
			\subsection{رفع مشکلات نشتی حافظه و اشاره‌گر معلق}
			
				\lr{R} به دلیل مدیریت خودکار حافظه، از مشکلاتی مانند اشاره‌گر معلق (\lr{Dangling Pointer}) جلوگیری می‌کند.
				مدیریت: اشیاء استفاده‌نشده توسط \lr{Garbage Collector} شناسایی و آزاد می‌شوند.
			
			\subsection{نتیجه‌گیری}
			
				\begin{itemize}
					
					\item \lr{R} طیف وسیعی از نوع‌های داده‌ای ساده و پیچیده را ارائه می‌دهد.
					
					\item حافظه به صورت خودکار و بهینه تخصیص می‌یابد.
					
					\item بازیافت حافظه به جلوگیری از مشکلات نشتی حافظه کمک می‌کند، و این ویژگی \lr{R} را برای تحلیل داده‌های پیچیده ایده‌آل می‌کند.
					
				\end{itemize}
				
	\chapter{برنامه نویسی تابعی}
	
		زبان R از برنامه‌نویسی تابعی (\lr{Functional Programming}) به طور کامل پشتیبانی می‌کند. \lr{R} طراحی شده است تا با داده‌ها به صورت برداری (\lr{vectorized}) کار کند و همین امر آن را برای عملیات تابعی بسیار مناسب می‌سازد. در ادامه به جزئیات سؤالات شما پاسخ داده می‌شود.
		
		\section{سازوکارهای برنامه‌نویسی تابعی در \lr{R}}
			
			\lr{R}
			شامل ویژگی‌ها و توابع متعددی برای پشتیبانی از برنامه‌نویسی تابعی است:
			
			\begin{enumerate}
				
				\item {\large توابع لامبدا (\lr{Lambda Functions})} \par
				در R، می‌توانید به‌صورت مستقیم توابع ناشناس (inline functions) تعریف کنید.
				مثال:
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Lambda Functions}}] 
squared <- function(x) x^2
result <- lapply(1:5, function(x) x^2)  # Using a lambda function
print(result)
		
						\end{lstlisting}
					\end{latin}
				
				
				\item {\large ارسال تابع به تابع} \par
				توابع در \lr{R} اشیاء درجه اول هستند، یعنی می‌توان آن‌ها را به عنوان آرگومان به دیگر توابع ارسال کرد.
				مثال:
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Passing function to another function}}] 
apply_function <- function(f, x) {
	f(x)  # Execute the input function
}
apply_function(sin, pi / 2)  # Passing sin function to another function

						\end{lstlisting}
					\end{latin}
				
				\item {\large بازگرداندن تابع از تابع} \par
				\lr{R}
				 اجازه می‌دهد که یک تابع از درون تابع دیگر بازگردانده شود.
				مثال:
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Return a function into function}}] 
generate_multiplier <- function(n) {
	function(x) x * n  # Return a new function
}
double <- generate_multiplier(2)
double(5)  # result: 10

						\end{lstlisting}
					\end{latin}
				
				\item {\large توابع نگاشت (\lr{Map})، فیلتر (\lr{Filter}) و کاهش (\lr{Reduce})} \par
				
					\begin{itemize}
						
						\item {\large \lr{map}}:
						توابعی مانند \lr{lapply} و \lr{sapply} برای اعمال یک تابع بر هر عنصر یک لیست یا بردار استفاده می‌شوند.
						
						\item {\large \lr{filter}}:
						تابع \lr{Filter} برای انتخاب عناصر مطابق با شرط استفاده می‌شود.
						
						\item {\large \lr{reduce}}:
						تابع \lr{Reduce} برای کاهش یک بردار به یک مقدار استفاده می‌شود.
						
					\end{itemize}
					
					مثال:
					
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Map - Filter - Reduce}}] 
# Map
squared <- sapply(1:5, function(x) x^2)

# Filter
filtered <- Filter(function(x) x > 2, 1:5)

# Reduce
sum_result <- Reduce(`+`, 1:5)

						\end{lstlisting}
					\end{latin}
				
			\end{enumerate}
			
		
		
		\section{پیاده‌سازی توابع برنامه‌نویسی تابعی در \lr{R}}
		
			این توابع با استفاده از مفاهیم بردارسازی (\lr{Vectorization}) و ارث‌بری از توابع پایه‌ای (\lr{Base functions}) در \lr{R} اجرا می‌شوند. \lr{R} در پشت صحنه، این عملیات را بهینه می‌کند، مثلاً با استفاده از کدهای نوشته‌شده در زبان \lr{C} برای عملکرد بهتر.
		
		
		\section{تأثیر توابع نگاشت، فیلتر و کاهش بر کارایی برنامه}
		
		استفاده از توابع تابعی (مانند \lr{sapply} یا \lr{Reduce}) معمولاً باعث افزایش کارایی می‌شود، زیرا این توابع در سطح پایین بهینه شده‌اند.
		این روش‌ها معمولاً کد خواناتر و کوتاه‌تری ایجاد می‌کنند که نگهداری آن‌ها آسان‌تر است.
		با این حال، برای مجموعه داده‌های کوچک ممکن است اختلاف کارایی قابل ملاحظه‌ای وجود نداشته باشد.
		
			
		\section{مقایسه با برنامه‌نویسی رویه‌ای (\lr{Procedural Programming})}
			
			برنامه‌نویسی تابعی می‌تواند از نظر کارایی و سادگی کد برتری داشته باشد، اما این به اندازه داده‌ها و کاربرد بستگی دارد.
			مثال:
		
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Map - Filter - Reduce}}] 
# Functional (Using Reduce)
system.time({
	result_func <- Reduce(`+`, 1:1e6)
})

# Procedural (Using Loop)
system.time({
	result_loop <- 0
	for (i in 1:1e6) {
		result_loop <- result_loop + i
	}
})

				\end{lstlisting}
			\end{latin}
			
			نتایج نشان می‌دهد که نسخه تابعی معمولاً سریع‌تر یا مشابه است، زیرا از بهینه‌سازی داخلی \lr{R} بهره می‌برد.
			
		
		\section{جمع‌بندی}
		
			\lr{R}
			به طور گسترده برنامه‌نویسی تابعی را پشتیبانی می‌کند و این روش می‌تواند به سادگی کد و گاهی افزایش کارایی منجر شود. با این حال، برای تصمیم‌گیری درباره بهترین روش، حجم داده‌ها و کاربرد خاص پروژه را باید در نظر گرفت.
			
			
	\chapter{برنامه نویسی رویه‌ای}
	
		زبان \lr{R} از برنامه‌نویسی رویه‌ای (\lr{Procedural Programming}) به خوبی پشتیبانی می‌کند. در این سبک برنامه‌نویسی، کد به صورت ترتیبی و از طریق توابع و زیربرنامه‌ها (\lr{subroutines}) سازماندهی می‌شود. در ادامه به جزئیات سؤالات شما در مورد سازوکارهای برنامه‌نویسی رویه‌ای در \lr{R} پاسخ داده می‌شود:
		
		\section{زیربرنامه‌ها (\lr{Subroutines})}
			
			در \lr{R}، زیربرنامه‌ها همان توابع هستند که می‌توانند کد تکراری یا پیچیده را درون خود مدیریت کنند. این توابع با استفاده از کلمه کلیدی \lr{function} تعریف می‌شوند.
			مثال:
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Subroutines}}] 
calculate_area <- function(length, width) {
	return(length * width)  # return value
}

area <- calculate_area(5, 3)  # Subroutine call
print(area)  # output: 15

				\end{lstlisting}
			\end{latin}
		
		\section{روش‌های ارسال متغیرها به توابع}
		
			در \lr{R}، متغیرها می‌توانند به دو روش به توابع ارسال شوند:
			
			\begin{enumerate}
				
				\item {\large ارسال بر اساس مقدار (\lr{Pass by Value})} \par
				
				\lr{R}
					به طور پیش‌فرض، متغیرها را به صورت "بر اساس مقدار" به توابع ارسال می‌کند. این بدان معناست که مقدار کپی می‌شود و تغییرات داخل تابع بر متغیر اصلی تأثیر نمی‌گذارد.
					مثال:
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Pass by Value}}] 
modify_value <- function(x) {
	x <- x + 1
	return(x)
}

a <- 10
result <- modify_value(a)
print(a)  # Original value does not change (output: 10)

						\end{lstlisting}
					\end{latin}
				
				\item {\large ارسال بر اساس مرجع (\lr{Pass by Reference})} \par
				
				برای ارسال متغیرها بر اساس مرجع، از اشیاء خاصی مانند لیست‌ها (\lr{lists}) یا محیط‌ها (\lr{environments}) استفاده می‌شود.
				مثال:
				
					\begin{latin}
						\begin{lstlisting}[caption={\lr{Pass by Reference}}] 
modify_reference <- function(env) {
	env$a <- env$a + 1  # Changing the value in the environment
}

e <- new.env()
e$a <- 10
modify_reference(e)
print(e$a)  # value changes (output: 11)

						\end{lstlisting}
					\end{latin}
				
			\end{enumerate}
		
		\section{برنامه‌نویسی عمومی (\lr{Generic Programming})}
		
			\lr{R}
			از توابع عمومی پشتیبانی می‌کند، به این معنا که توابع می‌توانند با انواع مختلف داده‌ها (اعداد، رشته‌ها، بردارها، و ...) کار کنند. \lr{R} به صورت پویا نوع داده را تشخیص می‌دهد و نیازی به تعریف نوع ورودی وجود ندارد.
			مثال:
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Generic Programming}}] 
print_value <- function(x) {
	print(x)  # The function works for any data type
}

print_value(42)       # integer
print_value("Hello")  # string
print_value(TRUE)     # logical

				\end{lstlisting}
			\end{latin}
			
			علاوه بر این، \lr{R} از سیستم‌های عمومی مانند \lr{S3}، \lr{S4} و \lr{Reference Classes} برای مدیریت رفتار توابع برای انواع مختلف داده‌ها استفاده می‌کند.
			مثال از روش \lr{S3}:
			\begin{latin}
				\begin{lstlisting}[caption={\lr{S3}}] 
print.custom <- function(x) {
	cat("Custom value:", x, "\n")
}

x <- 100
class(x) <- "custom"
print(x)  # Generic function call based on data type

				\end{lstlisting}
			\end{latin}
			
			
		\section{سایر ویژگی‌های برنامه‌نویسی رویه‌ای}
		
			\begin{itemize}
				
				\item {\large شرط‌ها و حلقه‌ها} \par
				
				\lr{R}
				شامل ساختارهای شرطی (\lr{if}, \lr{else}) و حلقه‌های تکرار (\lr{for}, \lr{while}, \lr{repeat}) برای اجرای منطقی و ترتیبی کد است.
				
				 \begin{latin}
					\begin{lstlisting}[caption={\lr{for}}] 
for (i in 1:5) {
	print(i)
}

					\end{lstlisting}
				\end{latin}
				
				\item {\large توابع پیش‌فرض (\lr{Default Arguments})} \par
				در \lr{R} می‌توان آرگومان‌های پیش‌فرض برای توابع تعریف کرد.
				مثال:
				
				\begin{latin}
					\begin{lstlisting}[caption={\lr{Default Arguments}}] 
greet <- function(name = "World") {
	cat("Hello,", name, "!\n")
}

greet()         # output: Hello, World!
greet("Alice")  # output: Hello, Alice!

					\end{lstlisting}
				\end{latin}
				
				
				\item {\large بازه‌های متغیر (\lr{Variable Scope})} \par
				
				متغیرها در \lr{R} دارای \lr{Local Scope} یا \lr{Global Scope} هستند.
				مثال:
				
				\begin{latin}
					\begin{lstlisting}[caption={\lr{Variable Scope}}] 
x <- 10  # متغیر جهانی
scope_example <- function() {
	x <- 5  # متغیر محلی
	return(x)
}
print(scope_example())  # output: 5
print(x)               # output: 10

					\end{lstlisting}
				\end{latin}
				
			\end{itemize}
		
		\section{مقایسه برنامه‌نویسی رویه‌ای با تابعی}
		
			\begin{itemize}
				
				\item برنامه‌نویسی رویه‌ای برای وظایف ترتیبی و ساده‌تر مناسب است.
				
				\item برنامه‌نویسی تابعی برای عملیات پیچیده‌تر و داده‌های بزرگ کارایی بیشتری دارد.
				
				\item در بسیاری از موارد، برنامه‌نویسی تابعی در \lr{R} به دلیل استفاده از بهینه‌سازی داخلی و بردارها سریع‌تر از حلقه‌های تکرار عمل می‌کند.
				
			\end{itemize}
		
		\section{جمع‌بندی}
		
			\lr{R}
			یک زبان انعطاف‌پذیر است که برنامه‌نویسی رویه‌ای را به طور کامل پشتیبانی می‌کند. این زبان ابزارهایی مانند توابع، روش‌های ارسال متغیر، توابع عمومی، و ساختارهای کنترلی را فراهم می‌کند که به توسعه کدهای خوانا و قابل نگهداری کمک می‌کنند.
			
	\chapter{برنامه‌نویسی شیءگرا}
	
		 زبان \lr{R} از برنامه‌نویسی شیءگرا (\lr{Object-Oriented Programming} یا \lr{OOP}) پشتیبانی می‌کند. \lr{R} از چندین سیستم برای مدیریت برنامه‌نویسی شیءگرا استفاده می‌کند، از جمله \lr{S3}، \lr{S4}، \lr{Reference Classes} ، و \lr{R6}. این سیستم‌ها هر کدام دارای ویژگی‌ها و سازوکارهای خاصی هستند که در ادامه توضیح داده می‌شوند.
		 
		 \section{ساختارهای موجود برای برنامه‌نویسی شیءگرا}
		 
		 	\begin{itemize}
		 		
		 		\item {\large سیستم \lr{S3}} \par
		 		
		 		\lr{S3}
		 		یک سیستم ساده و انعطاف‌پذیر برای شیءگرایی در \lr{R} است.
		 		
		 		\begin{itemize}
		 			
		 			\item 
		 			\lr{S3}
		 			از کلاس‌های غیررسمی و توابع عمومی (\lr{Generic Functions}) استفاده می‌کند.
		 			
		 			\item
		 			ساختار یک شیء \lr{S3} معمولاً لیستی است که با یک کلاس مشخص شده است.
		 			
		 		\end{itemize}
		 		
		 		مثال:
		 		
		 		\begin{latin}
		 			\begin{lstlisting}[caption={\lr{S3 OOP}}] 
# Defining an S3 object
person <- list(name = "Ali", age = 25)
class(person) <- "Person"

# Define a public function
print.Person <- function(x) {
	cat("Name:", x$name, "\nAge:", x$age, "\n")
}

print(person)

		 			\end{lstlisting}
		 		\end{latin}
		 		
		 		
		 		\item {\large سیستم \lr{S4}} \par
		 		\lr{S4}
		 		سیستم رسمی‌تر و قدرتمندتری است که از تعریف دقیق کلاس‌ها و متدها پشتیبانی می‌کند.
		 		
		 		\begin{itemize}
		 			
		 			\item نیاز به تعریف صریح کلاس‌ها با استفاده از \lr{setClass}.
		 			
		 			\item متدها با استفاده از \lr{setGeneric} و \lr{setMethod} تعریف می‌شوند.
		 			
		 		\end{itemize}
		 		
		 		مثال:
		 		
		 		\begin{latin}
		 			\begin{lstlisting}[caption={\lr{S3 OOP}}] 
# Defining a class S4
setClass("Person",
slots = list(name = "character", age = "numeric"))

# Create an object of class S4
person <- new("Person", name = "Ali", age = 25)

# Access to slots
print(person@name)

		 			\end{lstlisting}
		 		\end{latin}
		 		
		 		\item {\large \lr{Reference Classes}} \par
		 		
		 		این سیستم از \lr{OOP} کلاسیک (مشابه زبان‌هایی مانند \lr{Java} یا \lr{Python}) پشتیبانی می‌کند.
		 		
		 		\begin{itemize}
		 			
		 			\item امکان تعریف متغیرهای خصوصی و متدها.
		 			
		 			\item اشیاء به صورت ارجاعی مدیریت می‌شوند (یعنی تغییرات در متغیرها روی شیء اصلی اعمال می‌شوند).
		 			
		 		\end{itemize}
		 		
		 		مثال:
		 		
		 		\begin{latin}
		 			\begin{lstlisting}[caption={\lr{Reference Classes}}] 
Person <- setRefClass("Person",
fields = list(name = "character", age = "numeric"),
methods = list(
greet = function() {
	cat("Hello, my name is", name, "and I am", age, "years old.\n")
}
))

# Create object
person <- Person$new(name = "Ali", age = 25)
person$greet()

		 			\end{lstlisting}
		 		\end{latin}
		 		
		 		\item {\large سیستم \lr{R6}} \par
		 		
		 		\lr{R6}
		 		یک سیستم مدرن‌تر است که برای برنامه‌نویسی شیءگرا در \lr{R} طراحی شده است.
		 				 		
		 		\begin{itemize}
		 			
		 			\item متدهای \lr{R6} به طور مستقیم به اشیاء متصل هستند.
		 			
		 			\item برخلاف \lr{S3} و \lr{S4}، نیازی به تابع عمومی نیست.
		 			
		 		\end{itemize}
		 		
		 		مثال:
		 		
		 		\begin{latin}
		 			\begin{lstlisting}[caption={\lr{S6 OOP}}] 
library(R6)

Person <- R6Class("Person",
public = list(
name = NULL,
age = NULL,
initialize = function(name, age) {
	self$name <- name
	self$age <- age
},
greet = function() {
	cat("Hello, my name is", self$name, "and I am", self$age, "years old.\n")
}
))

# Create object
person <- Person$new(name = "Ali", age = 25)
person$greet()

		 			\end{lstlisting}
		 		\end{latin}
		 		
		 		
		 	\end{itemize}
		 
		 \section{چندریختی (Polymorphism)}
		 	
		 	\lr{R}
		 	از چندریختی به خوبی پشتیبانی می‌کند، به ویژه در سیستم‌های \lr{S3} و \lr{S4}.
		 	
			 	در \lr{S3} و \lr{S4}، توابع عمومی مانند \lr{print} بر اساس کلاس شیء رفتار متفاوتی از خود نشان می‌دهند.
			 	
			 	\begin{latin}
			 		\begin{lstlisting}[caption={\lr{Polymorphism}}] 
# Definition of two different classes
setClass("Rectangle", slots = list(length = "numeric", width = "numeric"))
setClass("Circle", slots = list(radius = "numeric"))

# General method definition for area calculation
setGeneric("area", function(obj) standardGeneric("area"))
setMethod("area", "Rectangle", function(obj) obj@length * obj@width)
setMethod("area", "Circle", function(obj) pi * obj@radius^2)

# use
rect <- new("Rectangle", length = 5, width = 3)
circle <- new("Circle", radius = 2)
area(rect)    # output: 15
area(circle)  # output: 12.566

			 		\end{lstlisting}
			 	\end{latin}
		 
		 \section{وراثت (Inheritance)}
		 
		 	\begin{itemize}
		 		
		 		\item در \lr{S3}، وراثت از طریق لیست کلاس‌ها (کلاس والد) انجام می‌شود.
		 		
		 		\item در \lr{S4}، وراثت به طور رسمی با استفاده از \lr{contains} تعریف می‌شود.
		 		
		 		\item در \lr{Reference Classes} و \lr{R6}، وراثت به صورت سلسله‌مراتبی تعریف می‌شود.
		 		
		 	\end{itemize}
		 	
		 	مثال در \lr{S4}:
		 
		 	\begin{latin}
		 		\begin{lstlisting}[caption={\lr{Inheritance}}] 
setClass("Shape", slots = list(color = "character"))
setClass("Rectangle", contains = "Shape", slots = list(length = "numeric", width = "numeric"))

# Create a rectangle
rect <- new("Rectangle", color = "blue", length = 5, width = 3)
rect@color  # Inherit the Color property from the Shape class

		 		\end{lstlisting}
		 	\end{latin}
		 
		 \section{مدیریت اشیاء در حافظه}
		 
		 	\begin{itemize}
		 		
		 		\item در سیستم‌های \lr{S3} و \lr{S4}، اشیاء به صورت کپی مدیریت می‌شوند، بنابراین تغییرات بر روی یک شیء معمولاً به نسخه کپی اعمال می‌شود.
		 		
		 		\item در سیستم‌های \lr{Reference Classes} و \lr{R6}، اشیاء به صورت ارجاعی (\lr{Reference}) مدیریت می‌شوند، یعنی تغییرات مستقیماً روی شیء اصلی اعمال می‌شود.
		 		
		 	\end{itemize}
		 
		 \section{جمع‌بندی}
		 
		 	زبان \lr{R} از برنامه‌نویسی شیءگرا با چندین سیستم (\lr{S3}، \lr{S4}، \lr{Reference Classes}، و \lr{R6}) پشتیبانی می‌کند.
		 	
		 	\begin{itemize}
		 		
		 		\item \lr{S3} برای کاربردهای ساده و انعطاف‌پذیر مناسب است.
		 		
		 		\item \lr{S4} برای مواردی که به دقت بیشتر در تعریف کلاس‌ها و متدها نیاز است.
		 		
		 		\item \lr{Reference Classes} و \lr{R6} برای برنامه‌های پیچیده‌تر و نیازمند مدیریت دقیق‌تر طراحی شده‌اند.
		 		
		 	\end{itemize}
		 	
		 	این ویژگی‌ها \lr{R} را به زبانی قدرتمند برای توسعه پروژه‌های شیءگرا تبدیل می‌کند.
		 	
	
	\chapter{برنامه‌نویسی همروند}
	
		زبان \lr{R} از برنامه‌نویسی همروند (\lr{Concurrent Programming}) پشتیبانی می‌کند. این قابلیت در \lr{R} از طریق بسته‌های مختلف و سازوکارهای گوناگونی مانند رشته‌ها (\lr{Threads})، ارسال پیام \lr{(Message Passing}، قفل‌ها (\lr{Locks})، و سمافورها (\lr{Semaphores}) پیاده‌سازی شده است. در ادامه به توضیحات مربوط به این سازوکارها پرداخته می‌شود.
		
		\section{رشته‌ها (\lr{Threads})}
		
			\lr{R}
			به صورت پیش‌فرض از رشته‌های چندگانه (\lr{Multithreading}) پشتیبانی نمی‌کند، زیرا \lr{R} برای اجرای تک‌رشته‌ای (\lr{Single Threaded}) طراحی شده است. با این حال، برای کارهای موازی و همروند از بسته‌های خارجی مانند \lr{parallel} و \lr{future} استفاده می‌شود.
		
		مثال: \lr{Multicore Processing}
		\begin{latin}
			\begin{lstlisting}[caption={\lr{Multicore Processing}}] 
library(parallel)

# Define a function to process
task <- function(x) {
	Sys.sleep(2)  # Simulation of a long operation
	return(x^2)
}

# Concurrent execution using processes
result <- mclapply(1:4, task, mc.cores = 4)
print(result)

			\end{lstlisting}
		\end{latin}
		
		\section{قفل‌ها (\lr{Locks}) و سمافورها (\lr{Semaphores})}
		
			برای مدیریت همزمانی و جلوگیری از شرایط رقابتی (\lr{Race Conditions})، می‌توان از قفل‌ها یا سمافورها استفاده کرد. در \lr{R} این قابلیت از طریق بسته‌هایی مانند \lr{parallel} و \lr{future} قابل دسترسی است.
			
			مثال: استفاده از قفل‌ها با \lr{parallel}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Locks in parallel}}] 
library(parallel)

# Create a lock
lock <- makeCluster(1)  # ایجاد یک کلاستر برای مدیریت دسترسی
clusterEvalQ(lock, { counter <- 0 })  # تعریف یک متغیر مشترک

# Increase shared variable value in safe mode
clusterExport(lock, "counter")
clusterEvalQ(lock, { counter <- counter + 1 })
stopCluster(lock)

				\end{lstlisting}
			\end{latin}
		
		\section{ارسال پیام (\lr{Message Passing})}
		
			\lr{R}
			از مکانیزم ارسال پیام برای ارتباط بین پردازه‌ها پشتیبانی می‌کند. این قابلیت عمدتاً با بسته‌هایی مانند \lr{parallel} و \lr{future} فراهم می‌شود.
			
			مثال: ارسال پیام با استفاده از \lr{makeCluster}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Message Passing in makeCluster}}] 
library(parallel)

# Create a cluster
cl <- makeCluster(2)

# Send and receive data between nodes
clusterExport(cl, "task")
result <- parLapply(cl, 1:2, function(x) x * 2)
print(result)

# Stop the cluster
stopCluster(cl)

				\end{lstlisting}
			\end{latin}
		
		\section{مدیریت همروندی با بسته‌های خاص}
		
			\begin{itemize}
				
				\item {\large بسته \lr{future}} \par
				بسته \lr{future} یک رابط ساده برای همروندی و محاسبات موازی فراهم می‌کند و از چندین \lr{backend} (مانند \lr{Multicore} و \lr{Multisession}) پشتیبانی می‌کند.
				
				\begin{latin}
					\begin{lstlisting}[caption={\lr{future package}}] 
library(future)

plan(multicore, workers = 4)  # Set for concurrent processing
result <- future_lapply(1:4, function(x) x^2)
print(result)

					\end{lstlisting}
				\end{latin}
				
				\item {\large بسته \lr{foreach}} \par
				بسته \lr{foreach} برای اجرای حلقه‌های همروند استفاده می‌شود.
			
				\begin{latin}
					\begin{lstlisting}[caption={\lr{foreach package}}] 
library(foreach)
library(doParallel)

cl <- makeCluster(4)
registerDoParallel(cl)

# Execution of the parallel loop
result <- foreach(i = 1:4, .combine = c) %dopar% {
	i^2
}
print(result)

stopCluster(cl)

					\end{lstlisting}
				\end{latin}
				
			\end{itemize}
		
		\section{مقایسه سمافورها و قفل‌ها در \lr{R}}
		
			\begin{itemize}
				
				\item {\large قفل‌ها (\lr{Locks})}:
				برای کنترل دسترسی به منابع مشترک استفاده می‌شوند. بسته‌های \lr{parallel} و \lr{future} این قابلیت را فراهم می‌کنند.
				
				\item {\large سمافورها (\lr{Semaphores})}: 
				به طور مستقیم در \lr{R} پشتیبانی نمی‌شوند، اما می‌توان از قفل‌ها برای پیاده‌سازی رفتار مشابه استفاده کرد.
				
			\end{itemize}
		
		\section{سایر سازوکارهای برنامه‌نویسی همروند}
		
			\begin{itemize}
				
				\item {\large اجرای غیرهمزمان (\lr{Asynchronous Execution})}:
				از طریق بسته‌هایی مانند \lr{async} و \lr{future} امکان‌پذیر است.
				
				\item {\large مدیریت حافظه مشترک}:
				\lr{R}
				به صورت پیش‌فرض از حافظه مشترک (\lr{Shared Memory}) پشتیبانی نمی‌کند، اما بسته‌هایی مانند \lr{bigmemory} این قابلیت را فراهم می‌کنند.
				
			\end{itemize}
		
		\section{مثالی کامل از برنامه‌نویسی همروند در R}
		
			ترکیب اجرای همروند و قفل‌ها:
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Combination of concurrent execution and locks}}] 
library(parallel)

# Define a shared variable
shared_counter <- 0

# Create a lock to manage access
cl <- makeCluster(2)

clusterExport(cl, c("shared_counter"))
clusterEvalQ(cl, {
	library(parallel)
	increment <- function(x) {
		Sys.sleep(1)
		x + 1
	}
})

# Run concurrently
result <- parLapply(cl, 1:4, function(x) increment(shared_counter))
print(result)

stopCluster(cl)

				\end{lstlisting}
			\end{latin}
		
		\section{جمع‌بندی}
		
			زبان \lr{R} از طریق بسته‌های داخلی و خارجی مانند \lr{parallel}، \lr{future} و \lr{foreach} از برنامه‌نویسی همروند پشتیبانی می‌کند. این ابزارها قابلیت‌هایی مانند قفل‌ها، ارسال پیام و مدیریت پردازش‌های موازی را فراهم می‌کنند. با این حال، برای پروژه‌های بسیار پیچیده، زبان‌هایی مانند \lr{Python} یا \lr{Java} ممکن است امکانات بیشتری برای مدیریت پیشرفته همروندی داشته باشند.
			
	\chapter{پیاده سازی چند الگوریتم معروف با \lr{R}}
	
		\section{جستجوی دودویی (\lr{Binary Search})}
		
		
			\begin{itemize}
				
				\item {\large هدف}:
				پیدا کردن موقعیت یک عنصر در یک آرایه مرتب‌شده.
				
				\item {\large روش کار}: \par
				
				\begin{itemize}
					
					\item ابتدا وسط آرایه را بررسی می‌کند.
					
					\item اگر مقدار وسط همان مقدار هدف باشد، موقعیت را برمی‌گرداند.
					
					\item اگر مقدار وسط کمتر از مقدار هدف باشد، جستجو را به نیمه‌ی راست ادامه می‌دهد.
					
					\item اگر مقدار وسط بیشتر باشد، جستجو در نیمه‌ی چپ انجام می‌شود.
					
				\end{itemize}
				
				\item {\large پیچیدگی زمانی}:
				\lr{$O(\log n)$}
				
				\item {\large کاربرد}:
				مناسب برای داده‌های مرتب‌شده.
			\end{itemize}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Binary Search}}] 
# 1. Binary Search
binary_search <- function(vec, target) {
	left <- 1
	right <- length(vec)
	
	while (left <= right) {
		mid <- floor((left + right) / 2)
		
		if (vec[mid] == target) {
			return(mid)
		} else if (vec[mid] < target) {
			left <- mid + 1
		} else {
			right <- mid - 1
		}
	}
	
	return(-1)  # Element not found
}

# Test Binary Search
binary_search(c(1, 3, 5, 7, 9), 5)

				\end{lstlisting}
			\end{latin}
			
		
		\section{مرتب‌سازی حبابی (\lr{Bubble Sort})}
			
			
			\begin{itemize}
				
				\item {\large هدف}:
				مرتب کردن یک آرایه به صورت صعودی.
				
				\item {\large روش کار}: \par
				
				\begin{itemize}
					
					\item هر عنصر را با عنصر مجاور مقایسه می‌کند و اگر لازم باشد، جای آن‌ها را عوض می‌کند.
					
					\item این کار را تا زمانی ادامه می‌دهد که آرایه کاملاً مرتب شود.
					
				\end{itemize}
				
				\item {\large پیچیدگی زمانی}:
				\lr{$O(n^2)$} در بدترین حالت.
				
				\item {\large کاربرد}:
				به دلیل سادگی برای آموزش مرتب‌سازی مناسب است، اما در عمل کند است.
				
			\end{itemize}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Bubble Sort}}] 
# 2. Bubble Sort
bubble_sort <- function(vec) {
	n <- length(vec)
	
	for (i in 1:(n - 1)) {
		for (j in 1:(n - i)) {
			if (vec[j] > vec[j + 1]) {
				temp <- vec[j]
				vec[j] <- vec[j + 1]
				vec[j + 1] <- temp
			}
		}
	}
	
	return(vec)
}

# Test Bubble Sort
bubble_sort(c(64, 34, 25, 12, 22, 11, 90))

				\end{lstlisting}
			\end{latin}
			
		
		\section{مرتب‌سازی سریع (\lr{Quick Sort})}
			
			
			\begin{itemize}
				
				\item {\large هدف}:
				مرتب کردن آرایه با استفاده از تقسیم و غلبه (\lr{Divide and Conquer}).
				
				\item {\large روش کار}: \par
				
				\begin{itemize}
					
					\item یک عنصر به عنوان محور (\lr{Pivot}) انتخاب می‌شود.
					
					\item عناصر کوچکتر از محور به یک بخش و بزرگترها به بخش دیگر تقسیم می‌شوند.
					
					\item هر بخش به صورت بازگشتی مرتب می‌شود.
					
				\end{itemize}
				
				\item {\large پیچیدگی زمانی} \par
				
				\begin{itemize}
					
					\item بهترین حالت:
					\lr{$O(n \log n)$}
					
					\item بدترین حالت:
					\lr{$O(n^2)$} (وقتی آرایه تقریباً مرتب باشد).
					
				\end{itemize}
				
				\item {\large کاربرد}:
				یکی از سریع‌ترین روش‌ها برای مرتب‌سازی در عمل.
				
			\end{itemize}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Quick Sort}}] 
# 3. Quick Sort
quick_sort <- function(vec) {
	if (length(vec) <= 1) {
		return(vec)
	}
	
	pivot <- vec[1]
	less <- vec[vec < pivot]
	equal <- vec[vec == pivot]
	greater <- vec[vec > pivot]
	
	return(c(quick_sort(less), equal, quick_sort(greater)))
}

# Test Quick Sort
quick_sort(c(10, 7, 8, 9, 1, 5))

				\end{lstlisting}
			\end{latin}
			
			
		\section{الگوریتم دایکسترا (\lr{Dijkstra's Algorithm})}
			
			
			\begin{itemize}
				
				\item {\large هدف}:
				پیدا کردن کوتاه‌ترین مسیر از یک گره مبدأ به تمام گره‌های دیگر در یک گراف وزندار.
				
				\item {\large روش کار}: \par
				
				\begin{itemize}
					
					\item فاصله مبدأ از خودش صفر و فاصله از سایر گره‌ها را بی‌نهایت فرض می‌کند.
					
					\item گره‌هایی که هنوز بازدید نشده‌اند، بررسی می‌شوند و فاصله کوتاه‌تر به‌روزرسانی می‌شود.
					
					\item این فرآیند تا زمانی ادامه می‌یابد که تمام گره‌ها بازدید شوند.
					
				\end{itemize}
				
				\item {\large پیچیدگی زمانی}:
				\lr{$O(V^2)$}
				) (با ماتریس مجاورت)، یا (
				\lr{$O((E+V) \log V)$}
				) با استفاده از صف اولویت.
				
				\item {\large کاربرد}:
				برای مسائل مسیر کوتاه، مانند مسیر‌یابی در نقشه.
				
			\end{itemize}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Dijkstra's Algorithm}}] 
# 4. Dijkstra's Algorithm
library(igraph)

dijkstra <- function(graph, source) {
	distances <- rep(Inf, vcount(graph))
	distances[source] <- 0
	visited <- rep(FALSE, vcount(graph))
	
	while (any(!visited)) {
		current <- which.min(ifelse(visited, Inf, distances))
		visited[current] <- TRUE
		
		neighbors <- neighbors(graph, current, mode = "out")
		for (neighbor in neighbors) {
			edge_weight <- E(graph)[get.edge.ids(graph, c(current, neighbor))]$weight
			distances[neighbor] <- min(distances[neighbor], distances[current] + edge_weight)
		}
	}
	
	return(distances)
}

# Create a test graph
g <- graph(edges = c(1, 2, 1, 2, 3, 2, 1, 3, 4), n = 3, directed = TRUE)
E(g)$weight <- c(1, 2, 4)

# Test Dijkstra's Algorithm
dijkstra(g, 1)

				\end{lstlisting}
			\end{latin}
			
		
		\section{مرتب‌سازی ادغامی (\lr{Merge Sort})}
			
			
			\begin{itemize}
				
				\item {\large هدف}:
				مرتب کردن آرایه با استفاده از رویکرد تقسیم و غلبه.
				
				\item {\large روش کار}: \par
				
				\begin{itemize}
					
					\item آرایه را به دو نیمه تقسیم می‌کند.
					
					\item هر نیمه را به صورت بازگشتی مرتب می‌کند.
					
					\item دو نیمه مرتب‌شده را با هم ادغام می‌کند.
					
				\end{itemize}
				
				\item {\large پیچیدگی زمانی}:
				\lr{$O(n\log n)$}
				
				\item {\large کاربرد}:
				بسیار کارآمد برای داده‌های بزرگ.
				
			\end{itemize}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{Merge Sort}}] 
# 5. Merge Sort
merge_sort <- function(vec) {
	if (length(vec) <= 1) {
		return(vec)
	}
	
	mid <- floor(length(vec) / 2)
	left <- merge_sort(vec[1:mid])
	right <- merge_sort(vec[(mid + 1):length(vec)])
	
	merge <- function(left, right) {
		result <- c()
		while (length(left) > 0 && length(right) > 0) {
			if (left[1] <= right[1]) {
				result <- c(result, left[1])
				left <- left[-1]
			} else {
				result <- c(result, right[1])
				right <- right[-1]
			}
		}
		return(c(result, left, right))
	}
	
	return(merge(left, right))
}

# Test Merge Sort
merge_sort(c(38, 27, 43, 3, 9, 82, 10))

				\end{lstlisting}
			\end{latin}
			
			
		\section{مسئله کوله‌پشتی (\lr{0/1 Knapsack Problem})}
			
			
			\begin{itemize}
				
				\item {\large هدف}:
				پیدا کردن ترکیبی از آیتم‌ها که بیشترین ارزش را در محدودیت وزن ارائه دهد.
				
				\item {\large روش کار}: \par
				
				\begin{itemize}
					
					\item از رویکرد برنامه‌ریزی پویا (\lr{Dynamic Programming}) استفاده می‌کند.
					
					\item یک ماتریس برای ذخیره بهترین مقدار ممکن در هر وزن و آیتم تا لحظه کنونی ایجاد می‌کند.
					
				\end{itemize}
				
				\item {\large پیچیدگی زمانی}:
				\lr{$O(n * W)$} 
				، که 
				\lr{$n$}
				تعداد آیتم‌ها و 
				\lr{$W$}
				ظرفیت کوله‌پشتی است.
				
				\item {\large کاربرد}:
				در مسائلی مانند بهینه‌سازی سرمایه‌گذاری یا مدیریت منابع.
				
			\end{itemize}
			
			\begin{latin}
				\begin{lstlisting}[caption={\lr{0/1 Knapsack Problem}}] 
# 6. Knapsack Problem (0/1)
knapsack <- function(weights, values, capacity) {
	n <- length(weights)
	dp <- matrix(0, n + 1, capacity + 1)
	
	for (i in 1:n) {
		for (w in 1:capacity) {
			if (weights[i] <= w) {
				dp[i + 1, w + 1] <- max(dp[i, w + 1], dp[i, w - weights[i] + 1] + values[i])
			} else {
				dp[i + 1, w + 1] <- dp[i, w + 1]
			}
		}
	}
	
	return(dp[n + 1, capacity + 1])
}

# Test Knapsack
knapsack(c(1, 2, 3), c(6, 10, 12), 5)

				\end{lstlisting}
			\end{latin}
			
	
	\begin{thebibliography}{9}
		
		\bibitem{RProject}
		\lr{The R Project for Statistical Computing}: وب‌سایت رسمی زبان \lr{R} که مستندات رسمی و جامع در مورد زبان، ساختارها، و پیاده‌سازی آن را ارائه می‌دهد.  
		
		\url{https://www.r-project.org}
		
		\bibitem{RDocumentation}
		\lr{R Documentation}: پایگاه داده‌ای گسترده از مستندات \lr{R} برای توابع و کتابخانه‌های مختلف.
		  
		\url{https://www.rdocumentation.org}
		
		\bibitem{AdvancedR}
		\lr{Advanced R by Hadley Wickham}: کتابی معتبر درباره مفاهیم پیشرفته در \lr{R}، شامل مدیریت حافظه، پیاده‌سازی داده‌ها، و مفاهیم مرتبط با حوزه تعریف.  
		
		\url{https://adv-r.hadley.nz}
		
		\bibitem{RForDataScience}
		\lr{R for Data Science}: کتابی از \lr{Hadley Wickham} و \lr{Garrett Grolemund} که اصول برنامه‌نویسی و تحلیل داده با \lr{R} را پوشش می‌دهد. 
		 
		\url{https://r4ds.had.co.nz}
		
		\bibitem{GarbageCollection}
		Garbage Collection in R: مستنداتی درباره جمع‌آوری زباله و مدیریت حافظه در \lr{R}. 
		 
		\url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/gc.html}
		
		\bibitem{RProgramming}
		\lr{R Programming for Data Science by Roger D. Peng}: کتابی با تمرکز بر اصول برنامه‌نویسی \lr{R} برای دانش داده و تحلیل آماری.  
		
		\url{https://leanpub.com/rprogramming}
		
		\bibitem{StackOverflow}
		\lr{Stack Overflow (R Tag)}: انجمنی فعال برای پرسش و پاسخ در مورد مسائل برنامه‌نویسی \lr{R}.  
		
		\url{https://stackoverflow.com/questions/tagged/r}
		
		\bibitem{CRAN}
		\lr{CRAN (Comprehensive R Archive Network)}: مخزن رسمی \lr{R} برای دانلود بسته‌ها و مستندات مرتبط.  
		
		\url{https://cran.r-project.org}
		
		\bibitem{W3Schools}
		\lr{W3Schools}: وب‌سایتی آموزشی برای یادگیری زبان \lr{R} و دیگر تکنولوژی‌های برنامه‌نویسی.  
		
		\url{https://www.w3schools.com/r/}
		
	\end{thebibliography}
	
	

\end{document}